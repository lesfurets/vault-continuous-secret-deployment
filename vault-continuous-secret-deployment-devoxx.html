<!doctype html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <title>Deploying your application secrets: Hashicorp Vault and continuous delivery</title>
    <meta name="description" content="Managing application secrets, like database credentials, passphrases, salts and private keys, is hard. The availability of those elements are critical to the application, yet they need to be properly secured to reduce the attack surface on your system. Most secret management systems, like Hashicorp Vault, are used as a centralized database, but it creates a single point of failure and it requires extra care in hardening the security of that system. How about deploying your secrets, in Hashicorp Vault, alongside your application? By leveraging your build infrastructure, you can deploy a copy of your secrets in a Vault that is secured using a one-time token, accessible only by your application. In this presentation, we'll show a continuous delivery pipeline that enables that approach, talk about the implications of handling secrets in your build infrastructure, and use threat modeling to verify the security of the deployed Vault.">
    <meta name="apple-mobile-web-app-capable" content="yes" />
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <link rel="stylesheet" href="bower_components/reveal.js/css/reveal.css">
    <link rel="stylesheet" href="bower_components/reveal.js/lib/css/zenburn.css">
    <link rel="stylesheet" href="css/theme.css" id="theme">
    <script>
      if (window.location.search.match(/print-pdf/gi)) {
        var link = document.createElement('link');
        link.rel = 'stylesheet';
        link.type = 'text/css';
        link.href = 'css/print/pdf.css';
        document.getElementsByTagName('head')[0].appendChild(link);
      }
    </script>
  </head>

  <body class="noFullScreen">
    <div id="footer" class="footer show">
      <img class="logo-lesfurets" src="img/logo_lesfurets_blanc.png">
      <div class="card">
        <p><strong><img class="logo" width="20px" src="img/logo_twitter.svg"><a href="https://alexandredubreuil.com" target="_blank">alexandredubreuil.com</a></strong></p>
        <p><a href="https://twitter.com/dubreuia"><img class="logo" width="20px" src="img/logo_twitter.svg"></a><a href="https://github.com/dubreuia"><img class="logo" width="20px" src="img/logo_github.svg"></a>@dubreuia</p>
      </div>
      <img class="logo-conference" src="img/logo_devoxx_france.jpg">
    </div>
    <div id="reveal" class="reveal">
      <div class="slides">

        <section>
          <img class="logo herve-francois" width="33%" src="img/lf_com_herve_francois.png">
          <h1>Deploying your application secrets: Hashicorp Vault and continuous delivery</h1>
          <p><strong>Alexandre DuBreuil | <a href="https://alexandredubreuil.com" target="_blank">alexandredubreuil.com</a></strong></p>
        </section>

        <section>
          <section>
            <h2>Welcome to the Furets!</h2>
          </section>
          <section>
            <h3>Alexandre DuBreuil</h3>
            <p>Freelance software engineer, conference speaker, open source maintainer and sound designer</p>
          </section>
          <section>
            <img width="50%" src="img/logo_lesfurets.png">
            <ul>
              <li>1 website, 5 Insurance Products : Car, Health, Home, Bike, Loan</li>
              <li class="emptyline">1 codebase, 450k lines of code, 60k unit tests, 150 selenium tests</li>
              <li>22 Developers, 2 DevOps, 4 Architects</li>
              <li class="emptyline">19 production servers including Load balancers, Frontend, Backend, Databases, BI</li>
              <li>1 release per day</li>
              <li class="emptyline">9 years of code history
                <br/>
              </li>
              <li>3M quotes/year, 40% of market share, 4M of customers</li>
            </ul>
          </section>
        </section>

        <section>
          <section>
            <h2>Context</h2>
          </section>

          <section data-transition="slide-in fade-out">
            <img width="66%" src="img/lf_car_journey.png">
          </section>

          <section data-transition="fade-in slide-out">
            <img width="66%" src="img/lf_com_car_price_sheet.png">
          </section>

          <section>
            <h3>Web application secrets</h3>
            <p>We define a <strong>secret</strong> as information that can be used to access sensitive data. Pretty much any information that we cannot put on a public repository. That includes:</p>
            <ul>
              <li>Insurer web service credentials (username, password)</li>
              <li>Encryption keys and key passphrases</li>
              <li>Salt for passwords and passphrases</li>
              <li>Database credentials (username, password)</li>
              <li><strong>Out of scope:</strong> customer credentials, PII</li>
            </ul>
          </section>

          <section>
            <h3>Secret in Java file</h3>
            <div class="code-wrapper">
              <pre class="prettyprint">
                <code class="code lang-java">
public class ClientPasswordCallback implements CallbackHandler {

  private static final String USERNAME = <mark class="fragment">"lesfurets"</mark>;
  private static final String PASSWORD = <mark class="fragment">"hunter2"</mark>;

  @Override
  public void handle(Callback[] callbacks) {
    final WSPasswordCallback pc = (WSPasswordCallback) callbacks[0];
    if (USERNAME.equals(pc.getIdentifier())) {
      pc.setPassword(PASSWORD);
    }
  }

}
                </code>
              </pre>
            </div>
          </section>

          <section>
            <h3>Secret in Tomcat server.xml</h3>
            <div class="code-wrapper">
              <pre class="prettyprint">
                <code class="code lang-xml">
&lt;?xml version='1.0' encoding='utf-8'?&gt;
&lt;Server port="1234" shutdown="SHUTDOWN"&gt;
  &lt;!-- ... --&gt;
  &lt;GlobalNamingResources&gt;
    &lt;Resource name="jdbc/b2b2cDatabase" 
              username="<mark class="fragment">dev</mark>"
              password="<mark class="fragment">hunter2</mark>"
              url="localhost:2345"
              type="javax.sql.DataSource"
              driverClassName="org.mariadb.jdbc.Driver"
              jdbcInterceptors="..."/&gt;
  &lt;/GlobalNamingResources&gt;
  &lt;!-- ... --&gt;
&lt;/Server&gt;
                </code>
              </pre>
            </div>
          </section>

          <section>
            <h3>Today's objective</h3>
            <p>Remove secrets from code and production machines</p>
          </section>

          <section>
            <h3>Overview of password workflow</h3>
            <p>Our objective is to have a workflow that works like this:</p>
            <ul>
              <li><strong class="color-zen-blue">Developer</strong> use password key in code (ex: <code>insurer_password</code>)</li>
              <li><strong class="color-zen-blue">Developer</strong> puts development value in code (ex: <code>hunter2</code>)</li>
              <li><strong class="color-zen-orange">Security</strong> admin adds production secret value in system</li>
              <li><strong class="color-zen-green">Developer</strong> deploys app without seeing the production value</li>
            </ul>
            <p>From code to production, different person with different access rights are handling secrets.</p>
          </section>

          <section>
            <h3>Prerequisite: Infrastructure as code</h3>
            <p>If you do <strong>infratructure as code</strong>, you probably have secrets in your source code. We want to keep infra as code, but remove the secrets.</p>
            <!-- https://image.slidesharecdn.com/deepdive-infrastructureascode-150702131406-lva1-app6892/95/deep-dive-infrastructure-as-code-17-638.jpg?cb=1435843061 -->
            <img width="33%" src="img/infra_as_code.jpg">
          </section>

          <section>
            <h3>Prerequisite: Lambda infrastructure</h3>
            <p><strong>Lambda infrastructure</strong> infra as code means you can reconstruct a machine "easily"</p>
            <p><strong>Lambda security</strong> means you can trash your secrets and reconstruct them "easily"</p>
          </section>

          <section>
            <h3>Prerequisite: Continuous delivery</h3>
            <p>At LesFurets we deliver code to production at least daily. Continuous delivery means that it is <strong>easy to push a feature to production</strong>, and also easy to push an <strong>old version in case of emergency</strong>.</p>
            <p>It also means we can lose the secrets container and still be able to replace it rapidly.</p>
            <img width="10%" src="img/logo_jenkins.jpg">
            <img width="10%" src="img/logo_teamcity.jpg">
          </section>

          <section>
            <h3>Prerequisite: Infrastructure automation</h3>
            <p>Our machine provisioning and deployment is done with Ansible. It makes <strong>staging possible</strong> by facilitating the creation of new environment and enables <strong>lambda infrastructure</strong>.</p>
            <img width="10%" src="img/logo_ansible.jpg">
            <img width="10%" src="img/logo_chef.jpg">
            <img width="10%" src="img/logo_puppet.jpg">
          </section>

        </section>

        <section>

          <section>
            <h2>Security</h2>
          </section>

          <section>
            <h3>Choosing a tool</h3>
            <p>Many tools are available for secrets management, yet not all will fit your purpose. Making your own <strong>custom solution</strong> might not be a good idea given how hard it is.</p>
            <ul>
            <li><strong class="color-zen-red">Ansible, Chef, etc.</strong> do not remove secrets on production machine <br/>(secrets retrieval at build time, not runtime)</li>
            <li><strong class="color-zen-orange">Keywhiz</strong> very similar to Vault and could have been a good choice</li>
            <li><strong class="color-zen-yellow">Amazon KMS</strong> similar to Vault, less featured (tied to the Amazon ecosystem)</li>
            <li><strong class="color-zen-green">Azure Key Vault</strong> similar to Vault (tied to the Microsoft ecosystem)</li>
            </ul>
          </section>

          <section>
            <h3>Runtime secrets vs Buildtime secrets</h3>
            <p>There are two approachs to remove secrets in source code, you fetch the secrets at:</p>
            <p><strong class="color-zen-red">Buildtime</strong> which means the production machine will have a cleartext copy of the secret</p>
            <p><strong class="color-zen-red">Runtime</strong> which means the production machine will dynamicaly get the secret, use it, then discard it, resulting in increased security</p>
          </section>

          <section>
            <h3>Hashicorp Vault</h3>
            <p>Lightweight, performant, open-source and battle hardened.</p>
            <ul>
              <li><strong>Seal</strong> and <strong>unseal</strong> makes your Vault safe (multiple key unlock)</li>
              <li><strong>Wrap</strong> secrets to distribute them safely</li>
              <li><strong>Authenticate</strong> with different methods (we're using token auth)</li>
              <li><strong>Single one-time connexion</strong> possible with wraped token</li>
              <li><strong>Audit log</strong> out of the box and easy to use</li>
            </ul>
            <p><img width="20%" src="img/logo_vault.jpg"></p>
          </section>

          <section>
            <h3>Our Vault usage context</h3>
            <p>Typical use case of Vault is different then what we'll see today: it is often used as a central database serving multiple apps and envs.</p>
            <img width="30%" src="img/vault_centralized.svg">
            <img width="30%" src="img/vault_decentralized.svg">
          </section>

          <section>
            <h3>Why use Vault decentralized?</h3>
            <ul>
              <li><strong>Continuous delivery</strong> easier to replace the secrets container</li>
              <li><strong>Version migration</strong> don't have to migrate secrets database</li>
              <li><strong>Attack surface</strong> infrastructure wide system with all the info</li>
              <li><strong>Staging</strong> deploying specific secrets for a specific env</li>
              <li><strong>SLA</strong> single point of failure, network issues</li>
              <li><strong>Master / slave</strong> configuration on enterprise solutions</li>
              <li><strong>Performance</strong> one local Vault per JVM is super-fast</li>
            </ul>
          </section>

<!--          <section> -->
<!--            <h3>Basic concepts</h3> -->
<!--            <p>Some concepts are required for this presentation</p> -->
<!--            <ul> -->
<!--              <li><strong>Secure Coding:</strong> TODO</li> -->
<!--              <li><strong>Threat model:</strong> a process by which potential (security) threats can be identified</li> -->
<!--              <li><strong>Attack surface:</strong> of a software environment is the sum of the different points where an unauthorized user can try to enter data to or extract data from an environment</li> -->
<!--              <li><strong>Man in the middle:</strong> is an attack where the attacker secretly relays and possibly alters the communication between two parties who believe they are directly communicating with each other</li> -->
<!--              <li><strong>One time password (OTP):</strong> is a password that is valid for only one login session or transaction</li> -->
<!--            </ul> -->
<!--          </section> -->

        </section>

        <section>

          <section>
            <h2>Threat model</h2>
          </section>

          <section>
            <h3>Threat model: STRIDE</h3>
            <p>There are many ways to do a threat model, one of them is using the STRIDE method.</p>
            <ul>
              <li><strong>S</strong>poofing of user identity</li>
              <li><strong>T</strong>ampering</li>
              <li><strong>R</strong>epudiation</li>
              <li><strong>I</strong>nformation disclosure</li>
              <li><strong>D</strong>enial of service</li>
              <li><strong>E</strong>levation of privilege</li>
            </ul>
            <p>You do the threat model of your system, and suppose the vendors do the same for theirs (you can ask for it).</p>
          </section>

          <section>
            <h3>Why a threat model?</h3>
            <p>Useful to make architecture decisions that takes into account security problems. Finding a problem doesn't mean you have to fix it, but you can assess the risk and decide later.</p>
          </section>

          <section data-background="img/vault_threat_model_01.svg" data-background-size="contain" data-background-color="#f3f3f3"></section>

          <section data-background="img/vault_threat_model_02.svg" data-background-size="contain" data-background-color="#f3f3f3"></section>

          <section data-background="img/vault_threat_model_03.svg" data-background-size="contain" data-background-color="#f3f3f3"></section>

          <section data-background="img/vault_threat_model_04.svg" data-background-size="contain" data-background-color="#f3f3f3"></section>

          <section data-background="img/vault_threat_model_05.svg" data-background-size="contain" data-background-color="#f3f3f3"></section>

          <section>
            <h3>Security design implications: decryption key</h3>
            <p>There is only <strong>one decryption key</strong> that can unseal (decrypt) the Vault. It's life-cycle is limited to the memory of the Ansible process running in a Docker on the build machine during deploy.</p>
            <p>That means that if any point the Vault is sealed (manually or not), it cannot be unsealed again</p>
            <p><strong>This is a possible security breach</strong>. In any case, the application needs to be redeployed</p>
          </section>

          <section>
            <h3>Security design implications: authentication</h3>
            <p>There is only <strong>one, single use, wrapped token</strong> than can provide the <strong>session token</strong>. Once the wrapped token is used, there is no other way of connecting to the Vault.</p>
            <p>If the connexion to the Vault is lost for too long (1 minute), the lease for the session token expires and the app cannot authenticate anymore.</p>
            <p><strong>This is a possible security breach</strong>. In any case, the application needs to be redeployed</p>
          </section>

          <section data-background="img/vault_token_wrap_lease_01.svg" data-background-size="contain" data-background-color="#f3f3f3"></section>

          <section data-background="img/vault_token_wrap_lease_02.svg" data-background-size="contain" data-background-color="#f3f3f3"></section>

          <section data-background="img/vault_token_wrap_lease_03.svg" data-background-size="contain" data-background-color="#f3f3f3"></section>

        </section>

        <section>

          <section>
            <h2>In practice</h2>
          </section>

          <section>
            <h3>Overview of delivery pipeline</h3>
            <!-- <p>Vault gets deployed before each tomcat instances, so 11 times for the production servers</p> -->
            <img width="50%" src="img/jenkins_pipeline_vault_packaging.jpg">
            <img width="75%" src="img/jenkins_pipeline_vault_deploy.jpg">
          </section>

          <section data-background="img/vault_infra_01.svg" data-background-size="contain" data-background-color="#f3f3f3"></section>

          <section data-background="img/vault_infra_02.svg" data-background-size="contain" data-background-color="#f3f3f3"></section>

          <section data-background="img/vault_infra_03.svg" data-background-size="contain" data-background-color="#f3f3f3"></section>

          <section data-background="img/vault_infra_04.svg" data-background-size="contain" data-background-color="#f3f3f3"></section>

          <section data-background="img/vault_infra_05.svg" data-background-size="contain" data-background-color="#f3f3f3"></section>

          <section data-background="img/vault_infra_06.svg" data-background-size="contain" data-background-color="#f3f3f3"></section>

          <section data-background="img/vault_infra_07.svg" data-background-size="contain" data-background-color="#f3f3f3"></section>

          <section data-background="img/vault_infra_08.svg" data-background-size="contain" data-background-color="#f3f3f3"></section>

          <section data-background="img/vault_infra_09.svg" data-background-size="contain" data-background-color="#f3f3f3"></section>

          <section data-background="img/vault_infra_10.svg" data-background-size="contain" data-background-color="#f3f3f3"></section>

          <section>
            <h3>Jenkins pipeline (groovy)</h3>
            <div class="code-wrapper smaller">
              <pre class="prettyprint">
                <code class="code lang-groovy">
dir('scripts/ansible') {
    withCredentials([usernamePassword(credentialsId: '<mark class="fragment">teamPasswordJenkinsUser</mark>',
                                      usernameVariable: '<mark class="fragment green">teamPasswordJenkinsUsername</mark>',
                                      passwordVariable: '<mark class="fragment orange">teamPasswordJenkinsPassword</mark>')]) {
        withEnv(["<mark class="fragment green">TEAM_PASSWORD_USERNAME</mark>=${teamPasswordJenkinsUsername}",
                 "<mark class="fragment orange">TEAM_PASSWORD_PASSWORD</mark>=${teamPasswordJenkinsPassword}"]) {
            sh """
            docker pull docker-hub.admin.courtanet.net/ansible
            docker run -w /playbooks \
                       -e <mark class="fragment green">TEAM_PASSWORD_USERNAME</mark> \
                       -e <mark class="fragment orange">TEAM_PASSWORD_PASSWORD</mark> \
                       -v \$(pwd):/playbooks \
                       docker-hub.admin.courtanet.net/ansible <mark class="blue">ansible-playbook ./tomcat-b2c.yml</mark> \
                       --inventory=./hosts \
                       --extra-vars='version=${scmHash} target=${conf.nginxEnvName}'
            """
        }
    }
}
                </code>
              </pre>
            </div>
          </section>

          <section>
            <h3>Deploying vault with Ansible</h3>
            <p>When the playbook <code>tomcat-b2c.yml</code> is called, Ansible will deploy Vault first with the steps previously shown.</p>
            <div class="code-wrapper">
              <pre class="prettyprint">
                <code class="code lang-groovy">
[09:31:13] vault - localhost - download from nexus ... | localhost | SUCCESS | 52ms
[09:31:14] vault - localhost - unarchive artifact ... | localhost | CHANGED | 916ms
[09:31:15] vault - localhost - fetch secrets ... | localhost | SUCCESS | 59ms
[09:32:23] vault - localhost - create vault ... | localhost | CHANGED | 5225ms
[09:32:28] vault - localhost - create sealed vault archive ... | localhost | CHANGED | 553ms
[09:32:28] vault - localhost - set vault_key, vault_token ... | localhost | SUCCESS | 120ms
...
                </code>
              </pre>
            </div>
          </section>

          <section>
            <h3>Build infrastructure implications</h3>
            <p><strong>Jenkins Credentials</strong> storage is used to connect to TPM. Ideally each environment has it's own credentials and each connexion is monitored.</p>
            <p><strong>Fetch secrets</strong> should not write to disk. Ansible is executed in a docker container with no volume to reduce leakage.</p>
            <p><strong>Deployment time is limited</strong> with a lease of 10 minutes on the wrapped token. Past that time, the application cannot unwrap the token and will not start.</p>
          </section>

          <section>
            <h3>Create Vault (bash)</h3>
            <p>Vault client is well made, but bootstrapping a Vault server with it properly with bash is finicky. Important parts are:</p>
            <ul>
            <li><strong>Initializing vault</strong> with 1 key to unseal</li>
            <li><strong>Creating a one-time token</strong> with wrapping and TTL</li>
            <li><strong>Revoking the root token</strong> and sealing the Vault</li>
            </ul>
          </section>

          <section>
            <div class="code-wrapper">
              <pre class="prettyprint">
                <code class="code lang-bash">
# Start vault with data and log directory (in the background) and check for startup
nohup vault server -config="conf/install.json" &amp;&gt; logfile &amp;
# (check for startup code omitted)

# Init vault with 1 key, save it and save the root token
<mark class="fragment">vault operator init -key-shares=1 -key-threshold=1</mark> -format="json" &gt; stdout
cat stdout | jq --raw-output ".unseal_keys_b64[0]" &gt; key
cat stdout | jq --raw-output ".root_token" &gt; token

# Unseal vault and authenticate with root token (without ~/.vault-token file)
vault operator unseal "$( &lt; key )"
vault login -no-store "$( &lt; token )"

# setting vault token for next operations
export VAULT_TOKEN="$( &lt; token )"
                </code>
              </pre>
            </div>
          </section>

          <section>
            <div class="code-wrapper">
              <pre class="prettyprint">
                <code class="code lang-bash">
# Add read only policy (dev, stage, etc.) for environment to vault
vault policy write "${ENVIRONMENT}" "policies/${ENVIRONMENT}.hcl"

# Mount a new key-value store for the environment (/dev, /stage, etc.)
vault secrets enable -path="${ENVIRONMENT}" kv

# Creates a wrapped token (needs to be unwraped before use), TTL is 10 minutes
<mark class="fragment">vault token create</mark> \
    -orphan \
    -renewable="true" \
    -policy="${ENVIRONMENT}" \
    <mark class="fragment">-ttl="${TOKEN_TTL}"</mark> \
    <mark class="fragment">-period="${TOKEN_TTL}"</mark> \
    <mark class="fragment">-wrap-ttl="${TOKEN_TTL}"</mark> \
    -format="json" \
    | jq --raw-output .wrap_info.token \
    &gt; wrap
                </code>
              </pre>
            </div>
          </section>

          <section>
            <div class="code-wrapper">
              <pre class="prettyprint">
                <code class="code lang-bash">
# Write secrets in vault
value=$( echo "${line}" | cut -d '=' -f 2- | sed 's/^@/\\@/g' )
vault write "${ENVIRONMENT}/${key}" "value=${value}"

# Enable audit log with syslog output (then goes to datadog)
vault audit enable syslog tag="vault-${ENVIRONMENT}-${INSTANCE}"

# Revoke root token, only otp tokens remains
<mark class="fragment">vault token revoke</mark> $( cat token )

# Seal and close the vault
<mark class="fragment">kill $( cat ${BUILD_DIR}/pid/vault.pid )</mark>

# Copy the files necessary to unseal the vault and authenticate
cat key &gt; ${KEY_FILE}
cat wrap &gt; ${TOKEN_FILE}
                </code>
              </pre>
            </div>
          </section>

          <section>
            <h3>Query Vault (Java)</h3>
            <p>Vault server has a <strong>simple REST API</strong> to query data, secured by SSL.</p>
            <p>You can use it directly in Java, or use a library like <code>spring-vault</code> (from Spring) or <code>vault-java-driver</code> (from BetterCloud)</p>
          </section>

          <section>
            <div class="code-wrapper small">
              <pre class="prettyprint">
                <code class="code lang-java">
<mark class="fragment">LOG.info("Vault using certificate");</mark>
SslConfig sslConfig = new SslConfig().pemFile(CERTIFICATE_PATH.toFile()).build();

<mark class="fragment">LOG.info("Vault response wrapping token validation (wrapToken)");</mark>
Vault vault = new Vault(new VaultConfig().sslConfig(sslConfig).address(ADDRESS).token(<mark class="fragment blue">wrapToken</mark>).build());
LogicalResponse lookup = vault.auth().lookupWrap();
String creationPath = lookup.getData().get("creation_path");
if (!"auth/token/create".equals(creationPath)) {
    throw logAndThrow("vault wrong wrapping token path '" + creationPath + "' <mark class="fragment">token might be forged</mark>");
}

<mark class="fragment">LOG.info("Vault unwrapping login token");</mark>
String <mark class="fragment green">sessionToken</mark> = vault.auth().unwrap().getAuthClientToken();

<mark class="fragment">LOG.info("Vault starting secure connexion (sessionToken)");</mark>
return new Vault(new VaultConfig().sslConfig(sslConfig).address(ADDRESS).token(<mark class="fragment green">sessionToken</mark>).build());
                </code>
              </pre>
            </div>
          </section>

          <section>
            <p>No more secrets in code!</p>
            <div class="code-wrapper">
              <pre class="prettyprint">
                <code class="code lang-java">
public class ClientPasswordCallback implements CallbackHandler {

  private static final VaultService VAULT = CoreServiceFactory.getInstance().getVaultClient();

  @Override
  public void handle(Callback[] callbacks) {
    final WSPasswordCallback pc = (WSPasswordCallback) callbacks[0];
    if (<mark class="fragment">VAULT.getSecret("username")</mark>.equals(pc.getIdentifier())) {
      pc.setPassword(<mark class="fragment">VAULT.getSecret("password")</mark>);
    }
  }

}
                </code>
              </pre>
            </div>
          </section>

          <section>
            <h3>Java design implications</h3>
            <p>Read <strong><a href="https://www.owasp.org/index.php/OWASP_Secure_Coding_Practices_-_Quick_Reference_Guide">OWASP Secure Coding Pratices</a></strong>, since even with the most secure Vault, if your Java development practices are bad, your system won't be secure.</p>
            <p>Basically, use <strong>short lived secret</strong> (stack memory, not heap memory) and <strong>no caching</strong>.</p>
          </section>

        </section>

        <section>

          <section>
            <h2>Operations</h2>
          </section>

          <section>
            <h3>Performance / Scalability</h3>
            <p>Using Vault decentralized makes it easier to manage, performance is not an issue if each JVM has it own Vault.</p>
            <p>It's also easier to scale by just <strong>adding new Vaults</strong> and more <strong>resilient to network failures</strong></p>
            <p>A single Vault instance handling 1500+ requests per seconds is totally reasonable on commodity hardware.</p>
          </section>

          <section>
            <h3>Monitoring / Alert plan</h3>
            <p>Along your monitoring, it's very important to <strong>know how to react when you have an alert</strong>.</p>
            <p><strong>Infrastructure (Datadog)</strong>: monitor CPU usage, memory and process number (each tomcat instance has a Vault instance)</p>
            <p><strong>Logs (Logmatic)</strong>: any <code>ERROR</code> log from the Vault service should be a potential security breach</p>
          </section>

          <section>
            <h3>Audit</h3>
            <p>The audit log is important for two separate reasons: in case of a breach you can <strong>diagnose what happened</strong> and you can <strong>detect a potential breach</strong>.</p>
            <p>For each operation on Vault, a new entry is added containing information about the request and the response.</p>
            <div class="code-wrapper">
              <pre class="prettyprint">
                <code class="code lang-bash">
vault audit enable syslog tag="vault-${ENVIRONMENT}-${INSTANCE}"
                </code>
              </pre>
            </div>
          </section>

<!--
{
  "time": "2019-03-19T13:51:46.332274315Z",
  "type": "response",
  "auth": {
    "client_token": "hmac-sha256:634fefbb92d09dbe7e3c2bfe9e954fa19219d6ea9e7d2d431149a5ada5a78fba",
    "accessor": "hmac-sha256:689210cb39e038be89a4ef8a0a60688f8ec4b0c2c3a80d459536cf2ea24ea09f",
    "display_name": "token",
    "policies": [
      "default",
      "stage"
    ],
    "token_policies": [
      "default",
      "stage"
    ],
    "metadata": null,
    "entity_id": ""
  },
  "request": {
    "id": "08c0b8ff-8916-dba9-3e50-79e7237ee74b",
    "operation": "update",
    "client_token": "hmac-sha256:634fefbb92d09dbe7e3c2bfe9e954fa19219d6ea9e7d2d431149a5ada5a78fba",
    "client_token_accessor": "hmac-sha256:689210cb39e038be89a4ef8a0a60688f8ec4b0c2c3a80d459536cf2ea24ea09f",
    "path": "auth/token/renew-self",
    "data": null,
    "policy_override": false,
    "remote_address": "127.0.0.1",
    "wrap_ttl": 0,
    "headers": {}
  },
  "response": {
    "auth": {
      "client_token": "hmac-sha256:634fefbb92d09dbe7e3c2bfe9e954fa19219d6ea9e7d2d431149a5ada5a78fba",
      "accessor": "hmac-sha256:689210cb39e038be89a4ef8a0a60688f8ec4b0c2c3a80d459536cf2ea24ea09f",
      "display_name": "token",
      "policies": [
        "default",
        "stage"
      ],
      "token_policies": [
        "default",
        "stage"
      ],
      "metadata": null,
      "entity_id": ""
    }
  },
  "error": ""
}
-->

          <section>
            <h3>Breach detection example</h3>
            <div class="horizontal">
              <div class="column">
                <div class="code-wrapper smaller">
                  <pre class="prettyprint">
                    <code class="code lang-json">
{
  "time": "2019-03-19T13:51:46",
  "auth": {
    "client_token": "hmac-sha256:...",
    ...
  },
  "request": {
    "id": "...",
    "operation": "update",
    "client_token": "hmac-sha256:...",
    "path": "auth/token/renew-self",
    "remote_address": "127.0.0.1",
    ...
  },
  "response": {
    ...
  },
}
                    </code>
                  </pre>
                </div>
              </div>
              <div class="column">
                <div class="code-wrapper smaller">
                  <pre class="prettyprint">
                    <code class="code lang-json">
{
  "time": "2019-03-19T13:51:46",
  "auth": {
    "client_token": "hmac-sha256:...",
    ...
  },
  "request": {
    "id": "...",
    "operation": "update",
    "client_token": "hmac-sha256:...",
    "path": "<mark class="fragment">funky/looking/url</mark>",
    "remote_address": "<mark class="fragment">123.123.123.123</mark>",
    ...
  },
  "response": {
    ...
  },
}
                    </code>
                  </pre>
                </div>
              </div>
            </div>
            <p>This is important to address, since any of those are potential security breaches.</p>
          </section>

        </section>

        <section>

          <section>
            <h2>Pitfalls</h2>
          </section>

          <section>
            <h3>Security is hard</h3>
            <p>The harder you make it for an attacker, the harder it is for you to use your own system.</p>
          </section>

          <section>
            <h3>Secrets migration</h3>
            <p><strong>True Story:</strong> all the insurer that had a "@" in their password crashed when we first deployed to production because of a failed char escape</p>
            <p>When migrating from cleartext to ciphertext, how do you test?</p>
            <ul>
            <li><strong>Automate migration:</strong> frown upon copy / paste</li>
            <li><strong>Production environment:</strong> that you can reproduce</li>
            </ul>
          </section>

          <section>
            <h3>Build all the things</h3>
            <p><strong>True Story:</strong> the SSL certificate was due to expire the same day that we realized it.</p>
            <ul>
            <li><strong>Automate everything:</strong> even certificate renewal</li>
            <li><strong>Small jobs:</strong> to redeploy small parts for emergencies</li>
            </ul>
            <p></p>
            <img src="img/meme_build_all_the_things.jpg" width="25%">
          </section>

          <section>
            <h3>Testing and mocking</h3>
            <p>You don't have access to your secrets anymore, than means you need to</p>
            <ul>
            <li><strong>refactor tests</strong> to test the secret key, not the value</li>
            <li><strong>mock vault</strong> and keep development values in code</li>
            <li><strong>reproduce production</strong> for authorized developers</li>
            </ul>
          </section>

        </section>

        <section>

          <section>
            <h2>Conclusion</h2>
          </section>

          <section>
            <h3>Wrapping up</h3>
            <p>Hashicorp Vault isn't necessarily the easiest program to automate. What it lacks in simplicity is compensated in excellent security features, a clean API and remarkable performance.</p>
            <p>By leveraging your build system, you can simplify secrets deployment and recover from incidents more easily.</p>
            <p>Security architecture is different for every program. Make sure you keep your goals and risks in mind when you design your solution.</p>
          </section>

          <section>
            <h3>Thank you!</h3>
          </section>

        </section>

        <section>

          <section>
            <h2>Annex</h2>
          </section>

          <section>
            <h3>Links</h3>
            <ul>
              <li>TODO</li>
              <li>https://www.vaultproject.io/docs/vs/chef-puppet-etc.html</li>
              <li>https://www.hashicorp.com/blog/using-hashicorps-vault-with-chef</li>
              <li>https://www.reddit.com/r/devops/comments/4hgxbh/hashicorps_vault_how_are_you_using_it/</li>
              <li>https://www.reddit.com/r/devops/comments/8zmibk/aws_secrets_manager_vs_hashicorp_vault_what_can/</li>
            </ul>
          </section>

          <section>
            <h3>TODO</h3>
            <ul>
              <li>TODO</li>
              <li>memory dump</li>
              <li>mocking, fallback, dev mode with docker</li>
              <li>what we're not using with vault</li>
            </ul>
          </section>

          <section>
            <h3>Question</h3>
            <ul>
              <li>TODO</li>
              <li>How to package certificate for SSL ?</li>
            </ul>
          </section>

          <section>
            <h3>Notes repetition 1</h3>
            <ul>
              <li>global talk about tpm</li>
              <li>(graph) 24 threat model talk about 2 things only: ott and key</li>
              <li>(graph) 24 threat model ott: wrap ttl 10 minutes, response wrapping forgery, session token ttl 1 minute</li>
              <li>(graph) 24 threat model key: memory only, stdin to remote script</li>
              <li>(graph) 33 add ttl to graph</li>
            </ul>
          </section>

        </section>

      </div>
    </div>
    <script src="bower_components/reveal.js/lib/js/head.min.js"></script>
    <script src="bower_components/reveal.js/js/reveal.js"></script>
    <script>
      // Full list of configuration options available here:
      // https://github.com/hakimel/reveal.js#configuration
      Reveal.initialize({
        controls: false,
        progress: true,
        history: true,
        center: true,
        embedded: true,
        mouseWheel: true,
        slideNumber: true,
        slideNumber: 'c/t',
        viewDistance: 5,

        width: 1280,
        height: 900,
        margin: 0,

        transition: Reveal.getQueryHash().transition || 'linear', // default/cube/page/concave/zoom/linear/fade/none

        // Optional libraries used to extend on reveal.js
        dependencies: [
          { src: 'bower_components/reveal.js/lib/js/classList.js', condition: function () { return !document.body.classList; } },
          { src: 'bower_components/reveal.js/plugin/markdown/marked.js', condition: function () { return !!document.querySelector('[data-markdown]'); } },
          { src: 'bower_components/reveal.js/plugin/markdown/markdown.js', condition: function () { return !!document.querySelector('[data-markdown]'); } },
          //{ src: 'bower_components/reveal.js/plugin/highlight/highlight.js', async: true, callback: function() { hljs.initHighlightingOnLoad(); } },
          { src: 'bower_components/reveal.js/plugin/zoom-js/zoom.js', async: true, condition: function () { return !!document.body.classList; } },
          { src: 'bower_components/reveal.js/plugin/notes/notes.js', async: true, condition: function () { return !!document.body.classList; } }
        ]
      });
    </script>
    <script src="https://code.jquery.com/jquery-3.2.1.slim.min.js"></script>
    <script src="js/script.js"></script>
    <script src="https://cdn.rawgit.com/google/code-prettify/master/loader/run_prettify.js?skin=desert&amp;callback=prettyCallback"></script>
  </body>
</html>
<!-- vim: set tabstop=2 softtabstop=2 shiftwidth=2 expandtab smarttab: -->
